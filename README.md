Welcome to our spiral!

We voluntarily solve algorithm problems on this repo that we call Spiralgo.

We will translate the solutions into many languages including Turkish, Korean, German.

You are more than welcome to join us.

![Welcome to our spiral!](https://avatars.githubusercontent.com/u/82793840?v=4)


 

[442. Find All Duplicates in an Array](https://github.com/spiralgo/algorithms/issues/98)

A칞캼klamas캼 issue i칞indedir.

[200. Number of Islands](https://github.com/spiralgo/algorithms/issues/97)

A칞캼klamas캼 issue i칞indedir.

[5. Longest Palindromic Substring](https://github.com/spiralgo/algorithms/issues/96)

A칞캼klamas캼 issue i칞indedir.

[207. Closest Binary Search Tree Value](https://github.com/spiralgo/algorithms/issues/95)

A칞캼klamas캼 issue i칞indedir.

[204. Count Primes](https://github.com/spiralgo/algorithms/issues/94)

A칞캼klamas캼 issue i칞indedir.

[Inverse Square Root Algorithm](https://github.com/spiralgo/algorithms/issues/1)
 
[Subset Sum Problem](https://github.com/spiralgo/algorithms/pull/102)

[Using the Monte Carlo Method to estimate Pi](https://github.com/spiralgo/algorithms/pull/103)
 
[Knapsack, Weighted Interval Scheduling Naive solutions ](https://github.com/spiralgo/algorithms/pull/100)

[0/1 Knapsack](https://github.com/spiralgo/algorithms/pull/105)


**CURATED 170 SORULARI:**

**EASY:**


  [游댰 LeetCode Curated Algo 170 EASY (T칲rk칞e):](https://github.com/spiralgo/algorithms/wiki/%F0%9F%94%B6-LeetCode-Curated-Algo-170---EASY-(T%C3%BCrk%C3%A7e)) 

**MEDUIM:**

[1265. Print Immutable Linked List in Reverse:](https://github.com/spiralgo/algorithms/issues/255)

[1490. Clone N-ary Tree:](https://github.com/spiralgo/algorithms/issues/256)

[1506. Find Root of N-Ary Tree:](https://github.com/spiralgo/algorithms/issues/257)

[1198. Find Smallest Common Element in All Rows:](https://github.com/spiralgo/algorithms/issues/261)

[723. Candy Crush:](https://github.com/spiralgo/algorithms/issues/262)

[1100. Find K-Length Substrings With No Repeated Characters:](https://github.com/spiralgo/algorithms/issues/264)

[366. Find Leaves of Binary Tree :](https://github.com/spiralgo/algorithms/issues/266)

[1522. Diameter of N-Ary Tree #174:](https://github.com/spiralgo/algorithms/issues/174)

[1101. The Earliest Moment When Everyone Become Friends:](https://github.com/spiralgo/algorithms/issues/185)

[1061. Lexicographically Smallest Equivalent String:](https://github.com/spiralgo/algorithms/issues/186)

[ 1244. Design A Leaderboard:](https://github.com/spiralgo/algorithms/issues/2)

[1564. Put Boxes Into the Warehouse I:](https://github.com/spiralgo/algorithms/issues/3)

[ 362. Design Hit Counter:](https://github.com/spiralgo/algorithms/issues/4)

[280. Wiggle Sort:](https://github.com/spiralgo/algorithms/issues/5)

[1236. Web Crawler:](https://github.com/spiralgo/algorithms/issues/6)

[1167. Minimum Cost to Connect Sticks:](https://github.com/spiralgo/algorithms/issues/7)

[484. Find Permutation:](https://github.com/spiralgo/algorithms/issues/8)

[311. Sparse Matrix Multiplication:](https://github.com/spiralgo/algorithms/issues/9)

[364. Nested List Weight Sum II:](https://github.com/spiralgo/algorithms/issues/11)


[582. Kill Process:](https://github.com/spiralgo/algorithms/issues/10)

Daha 칬nce 칬rendiklerimize dayanarak "Approach #3 HashMap + Depth First Search" 칞칬z칲m칲n칲n, bizim d칲칲nce 른klimize daha uygun oldu릇 kanaatindeyim.
LeetCode 칲zerindeki video izlenip konu 칞al캼캼lmal캼.

[1120. Maximum Average Subtree](https://github.com/spiralgo/algorithms/issues/12)

LeetCode'da bunun i칞in 칬nerilen "Approach 1: Postorder Traversal", bana g칬re de uygundur. 

Zir칙, post-order'da root en son hesaplan캼r.
 
 Bu y칲zden alttaki yavrular캼n ortalamas캼n캼 hesaplarken yukar캼 doru 칞캼kt캼캼 i칞in, onlar캼 hesaplarken elde etti를 verileri 칲st-node'lar i칞in de ayn캼 른kilde kullanabilece를 i칞in tekr칙r hesap yapmas캼na gerek kalmaz.
 


[370. Range Addition](https://github.com/spiralgo/algorithms/issues/13)

En y칲ksek puan캼 alm캼 olan 칞칬z칲m, bana kal캼rsa da uygundur:
https://leetcode.com/problems/range-addition/discuss/84217/Java-O(K-%2B-N)time-complexity-Solution

 Asl캼nda anlay캼nca 칞ok basit.
 startIndex'i ve endIndex'i, bir t칲r i칙retleme olarak kullan캼yor asl캼nda. Bu i르retler, en sonda i른 yarayacak.
 En sonda, bir dalgan캼n daha sonraki dalgalar캼 ileri doru itmesi gibi; ilk say캼dan ba륿ayarak son say캼ya doru bir dalga ba륿at캼yor.
 
  캻릆e, bu dalga, 칬n칲ne ald캼캼 her say캼n캼n g칲c칲n칲 asl캼nda bir sonrakilere de aktar캼yor.
  Mesela, bir indexte "3" rakam캼na rastlam캼릅a, "3"칲n g칲c칲n칲 ondan sonraki t칲m rakamlara aktarm캼 oluyor.
  캻릆e, (endIndex +1) numaral캼 indexe, "value" de른rinin negatif h칙lini atma sebebi de bu. 
  Bu negatif de른r de, dalga ile birlikte 칬n칲ndeki t칲m indexlere g칬nderilecek.
  B칬ylece, startIndex'ten gelen rakam캼n g칲c칲, endIndex'ten sonraki t칲m rakamlar i칞in s캼f캼rlanm캼, pasifle릀i olacak. 
  Bu sayede s칙dece startIndex ile endIndex aras캼na etki etmi olacak.
  Z칙ten istedi를 de bu idi.


[1087. Brace Expansion](https://github.com/spiralgo/algorithms/issues/14)

룟radaki 칞칬z칲m uygun g칬r칲n칲yor:
https://leetcode.com/problems/brace-expansion/discuss/312361/Java-DFS

Bu 칞칬z칲m vesilesi ile TreeSet veri yap캼s캼 칬renilmeli.

[426. Convert Binary Search Tree to Sorted Doubly Linked List](https://github.com/spiralgo/algorithms/issues/15)

Bunu tam da d칲칲nd칲칲m칲z gibi, Inorder rek칲rsif kullanarak 칞칬zm칲. 칂칲nk칲 inorder z칙ten bir Binary Tree'ye, k칲칞칲kten b칲y칲른 s캼ralayarak veriyor.
칂칬z칲m gayet akla yatk캼n.
Tan캼ma g칬re, e른r k칬k칲n sol alt a르c캼ndan s캼ral캼 bir linked list yaparsak, sonra sonuna k칬k칲 koyarsak, sonra ise sa alt a르c캼ndan bunu olu릆urursak elimizde bir t칲r LinkedList olmal캼. Bu da 칬zyineli algoritmay캼 verir. 

[1245. Tree Diameter](https://github.com/spiralgo/algorithms/issues/16)

Daha 칬nce bunun altyap캼s캼 gibi d칲칲n칲lebilecek, k캼smen daha kolay bir soru olan "1522. Diameter of N-Ary Tree" 칞칬zm칲릆칲k.

Bu sorudaki p칲f nokta, en derinden yani yapraklardan ba륿ayarak (depth-first) hesaplama yapmakt캼.

Bir yapra캼n uzunlu릇nu s캼f캼r olarak kabul edip, bunun 칲zerinden 칲stteki node'lar캼n uzunlu릇nu hesapl캼yorduk.

Diameter, ya alt node'larda 칞캼kabilirdi vey칙hud daha 칲st node'lardan. Hangisi uzun ise (Math.max kullanarak) onu al캼yorduk.

캻릆e bu 칞칬z칲m칲 ayn캼 른kilde uygulad캼캼 i칞in a를na oldu릇muz "Approach 3: DFS (Depth-First Search)" 칞칬z칲m칲 incelenmelidir.

[1538. Guess the Majority in a Hidden Array](https://github.com/spiralgo/algorithms/issues/17)

Burada en 칞ok oy alan 칞칬z칲m칲n alt캼nda, "blackspinner" adl캼 kullan캼c캼n캼n g칬nderdi를 g칬zden ge칞irilmi 칞칬z칲m칲 submit ettim.
캻nceledik칞e, buradaki notu g칲ncelleyece를m.

[1136. Parallel Courses](https://github.com/spiralgo/algorithms/issues/18)

 Bu soruda Approach 1: Breadth-First Search (Kahn's Algorithm) 칞칬z칲m칲 g칙yet uygun g칬r칲n칲yor.
 Bu ves칥le ile Kahn algoritmas캼n캼 da 칬renmi olaca캼z.
 
 T칲rk 칞ay캼 demlemek 칲zerinden Kahn's Algorithm'i anlatt캼m.
Topolojik s캼ralama i칞in gereken bu algoritmay캼 basit bir 칬rnekle akl캼n캼zda tutmak istiyorsan캼z izlemenizi 칬neririm.
 Kamera sallan캼yor ve dik tutmu릇m, ama gene de 칞ekim fen칙 de를l:
 https://youtu.be/99oTqO51Jh0
 
[510. Inorder Successor in BST II](https://github.com/spiralgo/algorithms/issues/19)

Bu soruda, "solution" k캼sm캼nda verilen "Approach 1: Iteration" gayet anla캼l캼r g칬r칲n칲yor.

[635. Design Log Storage System](https://github.com/spiralgo/algorithms/issues/20)

Burada "Approach #2 Better Retrieval" performans bak캼m캼ndan daha iyi oldu릇ndan ve TreeMap kullan캼m캼na dair yeni bir 칬rnek oldu릇ndan 칬t칲r칲 tercih edilmeli.

Burada convert methodu, t칲m tarihleri saniye cinsine 칞evirmeye yar캼yor.
Tarih aral캼캼 en fazla 2000 olabilece를 i칞in, convert metodunda 1999L (long t칲r칲nde 1999) 칞캼kar캼lm캼. 

Burada granularity metodunda yap캼lan 른y, verilen "gra" de른rinden sonraki t칲m de른rleri s캼f캼rlamak. 칂칲nk칲 onlar ciddiye al캼nmayacak.
Granularity metodundaki (boolean end) parametresi kontrol ediliyor 칞칲nk칲 e른r, bu gelen tarih; tarih aral캼캼n캼n biti를ni g칬steriyorsa; s캼f캼rlama i륿eminden sonra "gra" ile belirtilen yerin "1" art캼r캼lmas캼 gerekiyor.

칂칲nk칲, "put" ile girilen tarihleri TreeMap i칞erisine saniye cinsinden yaz캼yor. 
Tarih aral캼캼na g칬re sorgulama yaparken TreeMap i칞erisindeki tailMap(start) netodunu kullan캼yor. Bu method, parametre olarak g칬nderilen tarihe e를t veya ondan b칲y칲k olan tarihli listelerin id'lerini d칬nd칲r칲r. (Log bilgisi ile gelen ID'yi key olarak kullanm캼릆캼k)


[531. Lonely Pixel I ](https://github.com/spiralgo/algorithms/issues/21)

Bu soruda en fazla puan alan 칞칬z칲m g칙yet anla캼l캼r g칬r칲n칲yor. 


[369. Plus One Linked List](https://github.com/spiralgo/algorithms/issues/22)

Bu soruda standart 칞칬z칲m gayet uygun ve anla캼l캼r g칬r칲n칲yor:
Approach 1: Sentinel Head + Textbook Addition.

[281. Zigzag Iterator](https://github.com/spiralgo/algorithms/issues/23)

Burada kuyruk kullan캼lan Approach 2: Queue of Pointers, daha anla캼l캼r ve profesyonel g칬r칲n칲yor. 


[1135. Connecting Cities With Minimum Cost](https://github.com/spiralgo/algorithms/issues/24)

[Code](https://github.com/spiralgo/algorithms/blob/2f0b4d461c3e9a5afd2712b838aec56a7f7e4dab/src/main/java/algorithms/curated170/medium/ConnectingCitiesWithMinimumCost.java)

Bu gibi minimum-maksimum istenen sorularda genellik Greedy strateji uygulan캼r. Yani, neticenin ger칞ekten de maksimum-minimum olup olmad캼캼na bak캼lmaks캼z캼n, yerel olarak
eldeki verilerden en uygun g칬r칲nen ilkleri se칞ilerek i륿eme devam edilir.
 B칬yle en d칲칲k maliyetle 른hir birle릆irme sorular캼nda standart olarak Kruskal algoritmas캼 kullan캼l캼r. 칂칲nk칲, Kruskal, bir graftaki minimum-spanning tree denilen, en az m칙liyetli a르c캼 bukmak i칞in kullan캼lan bir algoritmad캼r. (Prim's Algorithm gibi)
 Kruskal bize 칞ok yabanc캼 gelmeyecektir 칞칲nk칲 kendi i칞inde "arkada grubu" probleminden hat캼rlad캼캼m캼z 
 Union-Find veri yap캼s캼n캼 kullan캼yor.
 
 Dolay캼s캼 ile, her ne kadar 칞칬z칲m uzun g칬r칲nse de, a르캼daki 칞칬z칲m uygun:
 Approach 1: Minimum Spanning Tree (Using Kruskal's algorithm)

 [Minimum Swaps to Group All 1's Together](https://github.com/spiralgo/algorithms/issues/25)
 
 Bu soruda "Approach 1: Sliding Window with Two Pointers" 칞칬z칲m칲 g칙yet uygun g칬r칲n칲yor. 칐nce pencere ile, en 칞ok 1 i칞eren k캼s캼m bulunuyor. Bu, toplam 1 say캼s캼ndan 칞캼kar캼l캼yor ve sonu칞 bulunuyor.
  
 [Design File System](https://github.com/spiralgo/algorithms/issues/26)
 
  Burada HashMap akla gelen ilk 칞칬z칲m oldu릇 i칞in, ilk 칞칬z칲m 칬nerisi olan "Approach 1: Dictionary for storing paths" g칙yet makul g칬r칲n칲yor. 
  
 [Longest Repeating Substring](https://github.com/spiralgo/algorithms/issues/27)
 
 Burada "Approach 1: Binary Search + Hashset of Already Seen Strings" gayet anla캼l캼r g칬r칲n칲yor. Z칙ten ikinci 칞칬z칲m칲n de temeli bu. 칖칞칲nc칲s칲 ise, 릇 칙n i칞in 칙cil olmayan bir form칲l 칬retiyor. Buna vakit kaybetmek doru g칬r칲nmedi.
   		 
 [Group Shifted Strings](https://github.com/spiralgo/algorithms/issues/28)
 
 (Not: Bu sorunun 칞칬z칲m mant캼캼n캼 daha iyi anlamak i칞in ba륾a bir soru olan "49. Group Anagrams" sorusunu incelemek faydal캼 olacakt캼r. Bu sorudaki temel 칞칬z칲m mant캼캼, anagramlar캼 bir "anahtar" arac캼l캼캼 ile grupland캼rmakt캼. Bu anahtar da, anagram캼n harflerinin k칲칞칲kten b칲y칲른 s캼ralanm캼 h칙li olarak se칞ilmi.)

 Bu soru i칞in, en 칞ok oy alan 칞칬z칲m칲n alt캼ndaki ilk yorumda verilen 칞칬z칲m uygun g칬r칲n칲yor. 칂칲nk칲 a칞캼klamas캼n캼 yapm캼 ve kod 칞ok s칙de g칬r칲n칲yor.
 Gene  "49. Group Anagrams" sorusunda oldu릇 gibi, kel칥meleri grupland캼racak bir anahtar aram캼 ve harflerin alf칙bedeki s캼ras캼ndan yararlanarak bulmu.
 
O 칞칬z칲m 릇radaki "diddit" adl캼 yazar캼n yorumundad캼r:
 https://leetcode.com/problems/group-shifted-strings/discuss/67442/My-Concise-JAVA-Solution
  		 
 [Remove Interval](https://github.com/spiralgo/algorithms/issues/29)
 
 룟radaki 칞칬z칲m, standart 칞칬z칲mden daha az ve 칬z g칬r칲n칲yor:
https://leetcode.com/problems/remove-interval/discuss/937333/Java-O(N)-check-left-and-right-boundary
   		 
 [Number of Distinct Islands](https://github.com/spiralgo/algorithms/issues/30)

  칂칬z칲mler aras캼nda en akla yatk캼n olan캼 "Approach 3: Hash By Path Signature" oldu릇 i칞in buna odaklanal캼m.

 [Number of Connected Components in an Undirected Graph](https://github.com/spiralgo/algorithms/issues/31)
  
  En 칞ok puan alm캼 olan 릇 칞칬z칲m gayet anla캼l캼r g칬r칲n칲yor:
  https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/discuss/77574/Easiest-2ms-Java-Solution

    		 
 [Campus Bikes](https://github.com/spiralgo/algorithms/issues/32)
 
  룟rada yeterince h캼zl캼 ve anla캼l캼r bir kod ve videolu anlat캼m var. 캻kinci video 캻ngilizce.:
  Burada mant캼k Bucket Sort 칲zerine kurulmu. Sonu칞ta uzakl캼k (distance) array'in uzunlu릇nun en fazla 2000 olabilece를 bilindi를nden; bisiklet se칞imleri en k칲칞칲k index ile belirlendi를nden, bu soru asl캼nda tam bir Bucket Sort sorusu haline geliyor.
https://leetcode.com/problems/campus-bikes/discuss/343953/Java-Solution-using-Bucket-Sort-with-Video-Explanation

 [Shortest Way to Form String](https://github.com/spiralgo/algorithms/issues/33)
  Buradaki ipucu 릇: target'캼n her bir harfi, source'un harflerini s캼ras캼 ile gezerek olu릆urulabiliyor mu? Bazen target'캼n her bir harfi i칞in source'u gezmeye ba릆an ba륿amak gerekir. 캻릆e, ka칞 kere ba릆an ba륿ad캼캼 soruluyor.
   Bunun i칞in s(ource), t(arget), pt (target'캼n o turdaki ilk konumu) 른klinde 3 pointer kullan캼yor. Bunlardan s ve t hareket ediyor. Pointer s hareket edip, t hareketsiz kald캼캼nda subsequence olu릆urmak i칞in gereken silme i륿emini yapm캼 oluyor.

  룟radaki 칞칬z칲me odaklanal캼m:
https://leetcode.com/problems/shortest-way-to-form-string/discuss/304193/Java-Two-Pointers-Solution-With-Explanation		 

 [Ternary Expression Parser](https://github.com/spiralgo/algorithms/issues/34)
 
 Bu soru, kodlama edit칬rlerinin nas캼l 칞al캼릆캼캼na dair fikir verecektir. 칂칲nk칲 Ternary Expression zaten bizim de s칲rekli kulland캼캼m캼z if-else k캼saltmas캼d캼r.
 Edit칬rler i릆e bu 른kilde parse ederek renklendiriyorlar. 
  
 룟 cevap Stack kullan캼larak 칞칬z칲lm칲. Burada Deque, daha 칬nce de bahsetti를m gibi hem Stack hem de Queue olarak kullan캼labilen bir yap캼.
 Gayet anla캼l캼r bir 칞칬z칲m:
https://leetcode.com/problems/ternary-expression-parser/discuss/92166/Very-easy-1-pass-Stack-Solution-in-JAVA-(NO-STRING-CONCAT)

 Bu 칞칬z칲mde p칲f nokta, Ternary Expression'u  "?" ile kar캼la캼ncaya kadar tersten Stack'e yazmak.  "?" ile kar캼la릀ak, Stack'in tepesinde  "?" olmas캼 anlam캼ndad캼r.
 Bu durumda, "?"'dan bir sonraki eleman 'T' vey칙 'F' olmal캼d캼r. T ise ilkini, F ise ikincisini tekr칙rdan Stack'e atma sebebi, bu expression'un birden fazla if칙de i칞erme ihtim칙lidir.
    	 
 [Walls and Gates](https://github.com/spiralgo/algorithms/issues/35)
 
 Buradaki kuyruk ile 칞칬z칲m칲 (Approach #2 (Breadth-first Search)) z칙ten en 칞ok oy alan 칞칬z칲m ile ayn캼d캼r.
 Dolay캼s캼 ile odaklanmam캼z gereken 칞칬z칲m budur.
 
    	 
 [Shortest Word Distance III](https://github.com/spiralgo/algorithms/issues/36)
 
  룟radaki 칞칬z칲m ba륿캼캼nda, "Java fast" ba륿캼캼 ile g칬sterilen ikinci 칞칬z칲m bize uygun g칬r칲n칲yor:
https://leetcode.com/problems/shortest-word-distance-iii/discuss/67097/12-16-lines-Java-C%2B%2B

 [Design Tic-Tac-Toe](https://github.com/spiralgo/algorithms/issues/37)

 Ba륿캼kta da belirtildi를 gibi g칙yet s칙de ve anla캼l캼r bir 칞칬z칲m:
https://leetcode.com/problems/design-tic-tac-toe/discuss/81898/Java-O(1)-solution-easy-to-understand

Burada p칲f nokta: diagonal (row == col oldu릇nda soldan sa르 칞apraz) ve antidiagonal (col == (cols.length - row - 1) oldu릇nda sa륷an sola 칞apraz) kontrolleri yapmakt캼r.
Sa륷an sola 칞apraz (antidiagonal) durumunda, row+col; sat캼r (vey칙 zaten e를t olduklar캼 i칞in s칲tun) say캼s캼n캼n 1 eksi를ni verir. 
  
    		 
 [Missing Element in Sorted Array](https://github.com/spiralgo/algorithms/issues/38)
 
  Dizinin s캼ral캼 olmas캼, bize Binary Search'칲 hat캼rlat캼yor. 
 Bu y칲zden ikinci yakla캼m olan "Approach 2: Binary Search" 칞칬z칲m칲 iyidir.
     
 [Find the Index of the Large Integer](https://github.com/spiralgo/algorithms/issues/39)
 
   Gene Binary Search'칲 hat캼rlatan bir soru. 룟radaki 칞칬z칲m gayet uygundur:

   https://leetcode.com/problems/find-the-index-of-the-large-integer/discuss/763124/JavaC%2B%2BCPython-Binary-Search 		 
 
 [Meeting Scheduler](https://github.com/spiralgo/algorithms/issues/40)
 
  캻ki pointer kullan캼lan "Approach 1: Two pointers" 칞칬z칲m칲n칲n anla캼lmas캼 daha kolayd캼r. 칐zetle, bu iki ki를nin o 칙nki slotlar캼 aras캼ndaki kesi른n zam칙n캼 buluyor.
  Bu kesi른n zam칙n e른r "duration"u tatmin ediyorsa, bunu d칬nd칲r칲yor. Yok e른r yetmiyorsa, pointerlardan birini hareket ettiriyor. Hangi slot erken bitiyorsa, o slotun pointer캼n캼 hareket ettiriyor.

  Bu soruyu, PriorityQueue veri yap캼s캼na dair tecr칲bemizi geni륿etmek ad캼na bir f캼rsat olarak g칬rmek istersek "Approach 2: Heap" 칞칬z칲m칲 g칙yet yerindedir.

 [Shortest Word Distance II](https://github.com/spiralgo/algorithms/issues/42)
 
 
   칂칬z칲m k캼sm캼nda, HashMap kullan캼larak yap캼lan "Approach 1: Using Preprocessed Sorted Indices" bu bak캼 a칞캼s캼 g칲zel.
     칐zetle yapt캼캼; Bir HashMap'te her bir kel칥meyi "key" olarak kullan캼yor ve onunla kar캼la릆캼캼 indexlerin Listesini de "value" olarak kullan캼yor.
     "Preprocessed Sorted Indices" demesinin sebebi, "value"deki listenin s캼ral캼 olmas캼d캼r.
     Daha sonra bu o 칙n "en k캼sa uzakl캼k" hesaplanmas캼 istenen kel칥melerin index listelerini al캼yor. Liste elemanlar캼n캼 tek tek kar캼la릆캼r캼yor. 

      
 [Campus Bikes II](https://github.com/spiralgo/algorithms/issues/41)
 
   룟 칞칬z칲mdeki, ikinci bak캼 a칞캼s캼 bize uygun g칬r칲n칲yor:
https://leetcode.com/problems/campus-bikes-ii/discuss/412367/Java-DFS-And-DP-Solution-with-Video-Explanation-(Chinese-and-English)

[Generalized Abbreviation](https://github.com/spiralgo/algorithms/issues/43)


   Bu bah칙ne ile Backtracking meselesini ara릆캼rmam캼z iyi olacakt캼r. Backtracking, bir satran칞 oyununda, bir sonraki hamleleri kafada hesaplay캼p uygun olmayan hamleleri elemeye benzetilebilir. Kafada satran칞 tahtalar캼n캼 ilerletip, olmay캼nca ad캼mlar캼 geri sarmak gibi.
        Bu y칲zden 릇 칞칬z칲m iyidir: "Approach #1 (Backtracking)"
	
   Detayl캼 not:	
   1-
   룟 videoda Backtrackingi anlatt캼m:
   Umar캼m bir faydas캼 olur.
   Neden algoritma 칞al캼릀am캼z gerekti를 gibi daha derin meselelerden de az da olsa bahsettim.
   https://youtu.be/uYrWVTPGUaw
   2-
   룟rada Abdul Bari, Backtracingi basit bir 칬rnekle anlatm캼:
    https://www.youtube.com/watch?v=DKCbsiDBN6c
   "캻ki erkek ve bir k캼z, 3 sandalyeye ka칞 farkl캼 른kilde oturabilir?"
   Bu gene YKS ile ilgili bir permutasyon sorusu.
   Ama bunu Backtracking ile 칞칬zmeye kalk캼nca ortaya bir a르칞 칞캼k캼yor.
   Backtracking'de "geri 칞ekilme" diye bir mesele var. Yani, e른r hamle i른 yaram캼yorsa, o hamleyi geri 칞ekmek.
   Bu soruda, ilk ba릆a bunu gerektiren bir k캼s캼tlama (constraint) yok.
   Ama 4 dakikada bir k캼s캼tlma belirliyor.
   K캼s캼tlamay캼 칬yle koyuyor? :
  "Girl should not sit in middle" (k캼z oraya oturamaz)
  Bu k캼s캼tlamay캼 koyunca, art캼k a르칞taki her bir dal 칞칬z칲m olam캼yor. Bu k캼s캼tl캼l캼ktan 칬t칲r칲, 칬nce a르c캼n dal캼n캼 gezip, buna uymayanlar캼 elemen gerekiyor.
  A르c캼n dal캼n캼n bir d칲칲m칲nde, bu k캼s캼tl캼l캼르 uymayan bir yerle kar캼la릆캼 isen, hemen geri bir 칬nceki d칲칲me geri 칞ekiliyorsun.


 [Paint House](https://github.com/spiralgo/algorithms/issues/44)
 
 Bu bir "Dynamic Programming" sorusudur.  "Dynamic Programming", bir problemin daha k칲칞칲k par칞alar캼 i칞in yap캼lan 칞칬z칲mleri haf캼zaya depolay캼p, onu problemin di른r par칞alar캼 i칞in de kullanmak olarak tan캼mlanabilir. Bunu anlamak i칞in 칬ncelikle  "Dynamic Programming" kullan캼larak yap캼lan "fakt칬riyel" program캼 yaz캼labilir.
        Bu bir  "Dynamic Programming" sorusu oldu릇ndan bunun a칞캼klamas캼n캼, "Solution" k캼sm캼nda en altta yapm캼륿ar. En alttaki 칞칬z칲m bizim i칞in de uygundur.
 
 [Count Univalue Subtrees](https://github.com/spiralgo/algorithms/issues/45)
 
   Approach 1: Depth First Search, bizim bak캼 a칞캼m캼za gayet uygundur.

 [Shortest Distance to Target Color](https://github.com/spiralgo/algorithms/issues/46)
 
  "Approach 1: Binary Search" bizim i칞in tan캼d캼k bir konu oldu릇ndan, bu 칞칬z칲m iyidir.
       
 [4 Keys Keyboard](https://github.com/spiralgo/algorithms/issues/47)
 룟rada dinamik programlama kullan캼larak yap캼lan ikinci 칞칬z칲m uygundur. G칲zel bir 른kilde a칞캼klam캼:
"Approach #1: Dynamic Programming [Accepted]"


 [The Maze](https://github.com/spiralgo/algorithms/issues/48)
 
  Standart 칞칬z칲mde verilen "Approach 1: Depth First Search" bize uygun g칬r칲n칲yor.

 [Construct Binary Tree from String](https://github.com/spiralgo/algorithms/issues/49)
  
  Standart 칞칬z칲mde verilen "Approach 2: Stack" y칬ntemi, bu sorudaki "a칞캼k-kapal캼" parantez mant캼캼na uygun oldu릇 i칞in buna odaklanal캼m.

 [Path With Maximum Minimum Value](https://github.com/spiralgo/algorithms/issues/50)
   
  
(M칲mk칲n yollardaki minimum de른rlerden, maksimum olan캼n캼 sordu릇 i칞in soru biraz kafa kar캼릆캼r캼c캼 olabilir. )

Bu soru PriorityQueue, Union Find, Binary Search kullan캼larak 칞칬z칲lebiliyor.

 Binary Search kullan캼lan y칬ntem en h캼zl캼s캼 olsa gerekir. 
 Binary search, aranan de른rin 0 ile  (high = Math.min(A[0][0], A[row-1][col-1])) de른ri aras캼nda olmas캼 gerekti를 ger칞e를ne dayan캼r.
 칂칲nk칲 bu iki node'un (yani A[0][0] ve A[row-1][col-1]) "m칲mk칲n yollar" 칲zerinde olmas캼 gerekti를 kesindir. 
 High de른ri, m칲mk칲n olan yollar i칞erisinde e른r minimumsa, skor z칙ten odur.
 E른r maksimumsa, aranan de른rin 1 ile high aras캼nda olaca캼 ger칞e를 de를릀ez. Bu y칲zden low = 1 ile High+1 aras캼nda Binary Search yaparak "low" de를륾eninin alabilece를 maksimum de른ri arar캼z.

 [Longest Substring with At Most Two Distinct Characters](https://github.com/spiralgo/algorithms/issues/51)
  
 Bu t칲r sorular genelde pencere y칬ntemi ile 칞칬z칲l칲r. Dolay캼s캼 ile "Approach 1: Sliding Window" uygundur.

 [Sort Transformed Array](https://github.com/spiralgo/algorithms/issues/51)

 룟radaki 칞칬z칲m gayet yal캼n g칬r칲n칲yor:
   https://leetcode.com/problems/sort-transformed-array/discuss/83322/Java-O(n)-incredibly-short-yet-easy-to-understand-AC-solution
   
 [First Unique Number](https://github.com/spiralgo/algorithms/issues/53)
 
Standart 칞칬z칲mdeki  "Approach 2: Queue and HashMap of Unique-Status" bu soruya uygun g칬r칲n칲yor.

 [Leftmost Column with at Least a One](https://github.com/spiralgo/algorithms/issues/54)
  
  Binary search bizim i칞in tan캼d캼k bir y칬ntem oldu릇ndan	 "Approach 2: Binary Search Each Row" 칞칬z칲m칲 uygundur.
 
 [3Sum Smaller](https://github.com/spiralgo/algorithms/issues/55)
  
Standart 칞칬z칲mdeki  "Approach #3 (Two Pointers)" bu soru i칞in uygun g칬r칲n칲yor.

 [Strobogrammatic Number II](https://github.com/spiralgo/algorithms/issues/57)
  
  룟 ba륿캼ktaki 칞칬z칲m g칙yet yal캼n g칬r칲n칲yor:
https://leetcode.com/problems/strobogrammatic-number-ii/discuss/67280/AC-clean-Java-solution
  
 [The Maze II](https://github.com/spiralgo/algorithms/issues/56)	
   
 Bunda da ayn캼 른kilde ilk Maze (labirent) sorusunda yapt캼캼m캼z gibi standart 칞칬z칲mdeki "Approach #1 Depth First Search" y칬ntemini se칞elim.

 [Binary Tree Longest Consecutive Sequence](https://github.com/spiralgo/algorithms/issues/58)
   	
 "Approach #2 (Bottom Up Depth-first Search)"dakine benzer bir 칞칬z칲m칲 "Tree Diameter" sorusunda kulland캼캼m캼z i칞in bu 칞칬z칲m
    
 [Max Consecutive Ones II](https://github.com/spiralgo/algorithms/issues/59)
   
Bununla ba륿ant캼l캼 olan 1151. "Minimum Swaps to Group All 1's Together" sorusunda yapt캼캼m캼z gibi, bunda da pencere y칬ntemini (Approach 2: Sliding Window) se칞elim.

 [Factor Combinations](https://github.com/spiralgo/algorithms/issues/60)	
    		
캻kinci en y칲ksek puan캼 alm캼 olan 칞칬z칲m, ilkinden 칞ok daha h캼zl캼:
https://leetcode.com/problems/factor-combinations/discuss/68039/A-simple-java-solution

 [Maximum Size Subarray Sum Equals k](https://github.com/spiralgo/algorithms/issues/61)
  
  룟radaki HashMap i칞eren 칞칬z칲m gayet yal캼n ve anla캼l캼r:
https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/discuss/77784/O(n)-super-clean-9-line-Java-solution-with-HashMap
 [Binary Tree Longest Consecutive Sequence II](https://github.com/spiralgo/algorithms/issues/62)
    "Approach #2 Single traversal" 칞칬z칲m칲 gayet anla캼l캼r ve h캼zl캼.

 [Binary Tree Vertical Order Traversal](https://github.com/spiralgo/algorithms/issues/63)
    	
 Di른r bir칞ok Tree sorusunda oldu릇 gibi, burada da derinlik 칬ncelikli arama "Approach 3: Depth-First Search (DFS)" daha uygun g칬r칲n칲yor.

 [Meeting Rooms II](https://github.com/spiralgo/algorithms/issues/64)
  
 Standart 칞칬z칲mdeki "Approach 2: Chronological Ordering" yakla캼m캼, zannedersem ayn캼 zamanda en 칞ok puan캼 alm캼 olan 칞칬z칲m ile ayn캼 mant캼캼 izliyor.

 [Bomb Enemy](https://github.com/spiralgo/algorithms/issues/65)

 Burada "Approach 2: Dynamic Programming" yakla캼m캼 uygundur.

 [Sentence Similarity II](https://github.com/spiralgo/algorithms/issues/66)

  Burada bize union-find kullan캼m캼n캼 hat캼rlatmas캼 a칞캼s캼ndan "Approach #2: Union-Find" yakla캼m캼 iyidir. Standart 칞칬z칲mde birka칞 de를를klik gerekiyordu. Liste yerine array kullan캼lm캼릆캼, onu d칲zelttik.

 [Flatten 2D Vector](https://github.com/spiralgo/algorithms/issues/67)	
    	
  Approach 2: Two Pointers, yakla캼m캼 gayet kolay. 칂칬z칲m k캼sm캼nda l칙f캼 fazla uzatm캼륿ar ama g칬r칲nd칲칲 kadar zor de를l.

 [Verify Preorder Sequence in Binary Search Tree](https://github.com/spiralgo/algorithms/issues/69)
 
  룟radaki en fazla puan alan 칞칬z칲m uygundur:
 
  https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/discuss/68142/Java-O(n)-and-O(1)-extra-space

 [Longest Line of Consecutive One in Matrix](https://github.com/spiralgo/algorithms/issues/68)

   Standart 칞칬z칲mler pek be른nilmemi. 룟rada en iyi puan캼 alan Java kodu uygun g칬r칲n칲yor:
https://leetcode.com/problems/longest-line-of-consecutive-one-in-matrix/discuss/102266/Java-O(nm)-Time-DP-Solution

 [Reverse Words in a String II](https://github.com/spiralgo/algorithms/issues/70)
  
 Standart 칞칬z칲m uygun g칬r칲n칲yor:
"Approach 1: Reverse the Whole String and Then Reverse Each Word"
 	
 [Longest Substring with At Most K Distinct Characters](https://github.com/spiralgo/algorithms/issues/71)	
  
 Daha 칬nce 칞칬zd칲칲m칲z "159. Longest Substring with At Most Two Distinct Characters" sorusu ile neredeyse ayn캼d캼r. 칂칬z칲m de ayn캼 른kilde pencere ve HashMap ile yap캼lacakt캼r.
   Bu y칲zden "Approach 1: Sliding Window + Hashmap." uygundur.

 [Add Bold Tag in String](https://github.com/spiralgo/algorithms/issues/72)	
 
 룟radaki 칞칬z칲m zekice g칬r칲n칲yor:
https://leetcode.com/problems/add-bold-tag-in-string/discuss/104248/Java-Solution-boolean-array

 [Closest Leaf in a Binary Tree](https://github.com/spiralgo/algorithms/issues/73)	
 
   Binary Tree'yi 칬nce bir Graf'a 칞evirmeyi 칬retti를 i칞in 릇 칞칬z칲m uygun g칬r칲n칲yor: Approach #1: Convert to Graph [Accepted]

 [Word Pattern II](https://github.com/spiralgo/algorithms/issues/74)	
 
   Daha 칬nce 칬rendi를miz	"Backtracking" metodu kulland캼캼 i칞in, buradaki 칞칬z칲m uygun g칬r칲n칲yor.
https://leetcode.com/problems/word-pattern-ii/discuss/73664/Share-my-Java-backtracking-solution

 [Find the Celebrity](https://github.com/spiralgo/algorithms/issues/75)	
 
   Standart 칞칬z칲mdeki "mant캼ksal 칞캼kar캼m" yani "Approach 2: Logical Deduction" y칬ntemi uygun g칬r칲n칲yor.
	
 [Graph Valid Tree](https://github.com/spiralgo/algorithms/issues/76)
 
   Daha 칬nceden bildi를miz Union-find kulland캼캼 i칞in "Approach 3: Advanced Graph Theory + Union Find" 칞칬z칲m칲 uygundur.

 [Inorder Successor in BST](https://github.com/spiralgo/algorithms/issues/77)
 
   Bu bir binary search tree oldu릇 i칞in, do르l olarak "Approach 2: Using BST properties" uygun 칞칬z칲md칲r.

 [All Paths from Source Lead to Destination](https://github.com/spiralgo/algorithms/issues/78)	
 
 Standart 칞칬z칲m: "Approach: Depth First Search" bize uygun g칬r칲n칲yor.
    	
 [Boundary of Binary Tree](https://github.com/spiralgo/algorithms/issues/79)
    
   Preorder s캼ralama, az 칞ok burada istedi를 gibi, bir a르c캼 sarmalayarak ilerledi를 i칞in, en uygun 칞칬z칲m do르l olarak: 
    Approach #2 Using PreOrder Traversal 

 [Maximum Distance in Arrays](https://github.com/spiralgo/algorithms/issues/80)
    
   룟radaki 칞칬z칲m, muhtemelen standart 칞칬z칲mde de kullan캼lm캼:
https://leetcode.com/problems/maximum-distance-in-arrays/discuss/104613/Java-Solution-Min-and-Max

 [Paint Fence](https://github.com/spiralgo/algorithms/issues/81)

  Standart 칞칬z칲mdeki "Approach 2: Dynamic Programming 1D - Bottom Up" bize uygun g칬r칲n칲yor.

 [Largest BST Subtree](https://github.com/spiralgo/algorithms/issues/82)
    	
   룟radaki 칞칬z칲m uygun g칬r칲n칲yor:
     https://leetcode.com/problems/largest-bst-subtree/discuss/78899/Very-Short-Simple-Java-O(N)-Solution

 [Palindrome Permutation II](https://github.com/spiralgo/algorithms/issues/83)	
    		Backtracking kullan캼lan 릇 y칬ntem uygun g칬r칲n칲yor: "Approach #2 Backtracking"  

 [Minimum Knight Moves](https://github.com/spiralgo/algorithms/issues/84)
 
   룟radaki 칞칬z칲mde her 른y ad캼m ad캼m a칞캼klanm캼:
    https://leetcode.com/problems/minimum-knight-moves/discuss/392053/Here-is-how-I-get-the-formula-(with-graphs)
 
 [Design Snake Game](https://github.com/spiralgo/algorithms/issues/85)

   Standart 칞칬z칲m g칙yet uygun g칬r칲n칲yor.

 [One Edit Distance](https://github.com/spiralgo/algorithms/issues/86)

  Standart 칞칬z칲m (Approach 1: One pass algorithm) gayet uygun g칬r칲n칲yor.

 [Encode and Decode Strings](https://github.com/spiralgo/algorithms/issues/87)
 
   룟radaki 칞칬z칲m en 칞ok oy alanlar aras캼nda ve g칙yet anla캼l캼r g칬r칲n칲yor:
  https://leetcode.com/problems/encode-and-decode-strings/discuss/70412/AC-Java-Solution
 
 [Insert into a Sorted Circular Linked List](https://github.com/spiralgo/algorithms/issues/88)
   	B칬yle Linked List sorular캼nda, iki pointer kullanmak akla yatk캼n g칬r칲n칲yor:
   "Approach 1: Two-Pointers Iteration"

**HARD:**

 [431. Encode N-ary Tree to Binary Tree:](https://github.com/spiralgo/algorithms/issues/89)

 [489. Robot Room Cleaner:](https://github.com/spiralgo/algorithms/issues/90)

 [759. Employee Free Time:](https://github.com/spiralgo/algorithms/issues/91)

 [1274. Number of Ships in a Rectangle:](https://github.com/spiralgo/algorithms/issues/92)
 
 [428. Serialize and Deserialize N-ary Tree:](https://github.com/spiralgo/algorithms/issues/210)

[1168. Optimize Water Distribution in a Village:](https://github.com/spiralgo/algorithms/issues/211)

[296. Best Meeting Point:](https://github.com/spiralgo/algorithms/issues/212)

[1183. Maximum Number of Ones:](https://github.com/spiralgo/algorithms/issues/213)

[527. Word Abbreviation:](https://github.com/spiralgo/algorithms/issues/214)

[1548. The Most Similar Path in a Graph:](https://github.com/spiralgo/algorithms/issues/215)

[1259. Handshakes That Don't Cross:](https://github.com/spiralgo/algorithms/issues/216)

[1231. Divide Chocolate:](https://github.com/spiralgo/algorithms/issues/217)

[272. Closest Binary Search Tree Value II:](https://github.com/spiralgo/algorithms/issues/218)

[302. Smallest Rectangle Enclosing Black Pixels:](https://github.com/spiralgo/algorithms/issues/219)

[425. Word Squares:](https://github.com/spiralgo/algorithms/issues/220)

[1216. Valid Palindrome III:](https://github.com/spiralgo/algorithms/issues/221)

[471. Encode String with Shortest Length:](https://github.com/spiralgo/algorithms/issues/222)
 
[774. Minimize Max Distance to Gas Station:](https://github.com/spiralgo/algorithms/issues/223)

[465. Optimal Account Balancing:](https://github.com/spiralgo/algorithms/issues/224)

[642. Design Search Autocomplete System:](https://github.com/spiralgo/algorithms/issues/225)

[588. Design In-Memory File System:](https://github.com/spiralgo/algorithms/issues/226) 

[265. Paint House II:](https://github.com/spiralgo/algorithms/issues/227) 

[1088. Confusing Number II:](https://github.com/spiralgo/algorithms/issues/228) 

[772. Basic Calculator III:](https://github.com/spiralgo/algorithms/issues/229) 

[317. Shortest Distance from All Buildings:](https://github.com/spiralgo/algorithms/issues/230) 
  		 		
[499. The Maze III:](https://github.com/spiralgo/algorithms/issues/231) 

[727. Minimum Window Subsequence:](https://github.com/spiralgo/algorithms/issues/232) 

[568. Maximum Vacation Days:](https://github.com/spiralgo/algorithms/issues/233) 

[305. Number of Islands II:](https://github.com/spiralgo/algorithms/issues/234) 

[1199. Minimum Time to Build Blocks:](https://github.com/spiralgo/algorithms/issues/235) 

[308. Range Sum Query 2D - Mutable:](https://github.com/spiralgo/algorithms/issues/236) 

[158. Read N Characters Given Read4 II - Call multiple times:](https://github.com/spiralgo/algorithms/issues/237) 

[358. Rearrange String k Distance Apart:](https://github.com/spiralgo/algorithms/issues/238) 

[1153. String Transforms Into Another String:](https://github.com/spiralgo/algorithms/issues/239) 

[644. Maximum Average Subarray II:](https://github.com/spiralgo/algorithms/issues/240) 

[269. Alien Dictionary:](https://github.com/spiralgo/algorithms/issues/241) 

[631. Design Excel Sum Formula:](https://github.com/spiralgo/algorithms/issues/242) 

[656. Coin Path:](https://github.com/spiralgo/algorithms/issues/243) 
 
